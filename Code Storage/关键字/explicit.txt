//带有一个参数的构造函数的隐式类型转换和explicit 关键字

//1．当类中带有一个参数的构造函数时，将执形对象的隐式转换，比如有类A，有一个带有一个参数的构造函数A(int i){}
//则当出现语句A m=1;就会调用带有一个参数的构造函数来创建对象m，也就是将语句转换为A m(1)的形式.
//2．如果有一个函数，比如void f(Aj){}这个函数需要一个类A 的对象作为参数，但是当调用语句为f(2)时，同样能调用
//这个函数，这时函数的形参A j 被解释为，A j=2  即会隐式调用带有一个参数的构造函数来创建一个对象j 。但是有
//一种形式的函数定义当出现语句f(2)这样的调用时会出错，就是函数f 定义的形式为void  f(A  &j){}定义一个接受一
//个实参的引用时会出错，具体原因不清楚。但这几种情况都能正确调用void f(Aj){} , void f(const Aj){} ; void f(const A &j){}.
//3．如果不需要这种隐式的类型转换则在构造函数前使用关键字explicit，这个关键字只能用于构造函数前。如果在构造 
//函数前使用explicit 关键字，这时语句A m=1 和f(2)都将出错。

//例：带一个参数的构造函数的隐式类型转换情况 
class A
{
public:
	int b;
	A()
	{
		b = 0;
	}

	~A()
	{
		cout<<"xi"<<endl;
	}

	A(int i)//定义带有一个参数的构造函数，此构造函数存在类类型间的隐式转换问题 
	{
		b = i;
		cout<<"gou"<<endl;
	};
};

//以下是几种正确定义的f函数，这些函数不会在f(2)这样的调用时出错 
形式1: void f(A j){}
形式2: void f(const A& j){}
形式3: void f(const A j){}
void f(const A& j) { cout<<"f"<<endl<<j.b;}
void f(A &j){}
//错误当出现f(2)这样的调用时会出错，但f(m)其中m是A的对象不会出错。具体原因还不清楚，
//系统提示不能将int类型转换为A &类型的错误。


int main() 
{
	A m = 1;
	cout<<m.b<<endl;//输出1，语句m=1会处理成m(1)的形式，即隐式被转换为掉用带有一个参数的构造函数。

	f(2);
}

//调用f 函数输出f和2，这里很奇怪，明明f 函数是接受一个A类型的对象，但这里用整数也能正确调用，原因就在于A类中定义
//了一个带有一个参数的构造函数，当调用这个函数时f函数的形参A j会被自动转换为A j = 2 的形式，即调用类A中带有一个参数的构造函
//数来构造一个对象 j。