#ifndef __TDPROC_HOOK_IOC_H__
#define __TDPROC_HOOK_IOC_H__

#define IOCTL_TDPROCHOOK_ENABLE_TERMINATE \
	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TDPROCHOOK_DISABLE_TERMINATE \
	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TDPROCHOOK_SET_DENY_REPORT_EXECUTE \
	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TDPROCHOOK_SET_EXECUTE_RULE \
	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TDPROCHOOK_SET_USB_NOEXCUTE \
	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TDPROCHOOK_SET_DEVICE_NAME \
	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define MAX_CHECKSUM_SIZE		2048

#define RULE_TYPE_MASK			0x01
#define RULE_ALLOW_ACCESS		0x01
#define RULE_DENY_ACCESS		0x00

#define RULE_ALL_FILES			0x02
#define RULE_CHECKSUM_PRESENT	0x04
#define RULE_PATH_PRESENT		0x08

#define RULE_PATH_TYPE_MASK			0x300
#define RULE_FILE_NAME				0x000
#define RULE_FULL_PATH				0x100
#define RULE_DIRECTORY				0x200
#define RULE_DIRECTORY_RECURSIVE	0x300

#define RULE_MATCH_MASK			0x80000000

typedef struct _TDPROCHOOK_EXECUTE_RULE_ITEM
{
	DWORD dwMasks;
	DWORD dwCheckSum;
	DWORD dwPathOffset;
} TDPROCHOOK_EXECUTE_RULE_ITEM, *PTDPROCHOOK_EXECUTE_RULE_ITEM;

#pragma warning(push)
#pragma warning(disable: 4200)

// TDPROCHOOK_EXECUTE_RULE_ITEM with low index has higher priority
typedef struct _TDPROCHOOK_EXECUTE_RULE
{
	DWORD dwSize;
	DWORD dwCount;
	// ruleItems[dwCount]
	// char aszPath[dwCount][]
} TDPROCHOOK_EXECUTE_RULE, *PTDPROCHOOK_EXECUTE_RULE;

#define MAX_DEVICE_COUNT	26

typedef struct _TDPROCHOOK_DEVICE_DRIVE
{
	char szDeviceName[MAX_DEVICE_COUNT];
	char szDevicePath[MAX_DEVICE_COUNT][MAX_PATH];
} TDPROCHOOK_DEVICE_DRIVE, *PTDPROCHOOK_DEVICE_DRIVE;

#pragma warning(pop)

#endif //__TDPROC_HOOK_IOC_H__